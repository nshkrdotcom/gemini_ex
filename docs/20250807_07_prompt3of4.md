### **Prompt 3 of 4: Implementing the LATER Runtime and Manual Loop API**

**Objective:** With the data contracts for both sending tool definitions and handling `functionCall`/`functionResponse` turns now in place, you will implement the execution layer. This involves integrating the `Altar.LATER` runtime into the `gemini_ex` application, exposing a high-level `Gemini.Tools` facade for developers, and formalizing the chat history management to robustly support multi-turn tool-calling conversations.

**Required Reading (CRITICAL):**

1.  **Context Document - `docs/20250807_02_alter_and_later_initial_impl.md`**:
    *   Review **Stage 2: Manual Tool Execution Loop**. This document provides the high-level strategy you will be implementing: supervising a `Registry` instance, creating a `Gemini.Tools` module, and handling the `FunctionResponse` turn.

2.  **Context Document - `docs/20250807_03_alter_and_later_initial_impl.md`**:
    *   Read **Sub-Task 2.2: The Immutable History Problem**. This is a critical design decision. You will formalize the chat state management from a simple map into a dedicated `Gemini.Chat` struct and module to ensure immutable history updates, as described.

3.  **ALTAR Codebase (`./ALTER/`)**:
    *   `README.md`: The "Usage Guide" section (lines 106-163) shows the canonical interaction pattern between the `Registry` and `Executor`.
    *   `lib/altar/later/registry.ex`: Understand the public API: `start_link/1`, `register_tool/3`, and `lookup_tool/2`.
    *   `lib/altar/later/executor.ex`: Understand the public API, specifically `execute_tool/2`. Note that it is stateless.
    *   `lib/altar/supervisor.ex`: Note how the `Registry` is started and named (line 21). You will replicate this pattern.

4.  **Gemini Codebase (`./`)**:
    *   `gemini/application.ex`: Review the existing `start/2` function (lines 6-12). You will add a new supervisor as a child here.
    *   `gemini.ex`: Review the existing `chat/1` and `send_message/2` functions (lines 201-240). You will be replacing this ad-hoc implementation with your new, more robust `Gemini.Chat` module.

**Agent Directive:**

1.  **Supervise the Registry:**
    *   Create a new supervisor module at `gemini/supervisor.ex`.
    *   This `Gemini.Supervisor` must start the existing `Gemini.Streaming.UnifiedManager` and a new `Altar.LATER.Registry` process.
    *   The `Altar.LATER.Registry` child specification **must** give it a registered name: `name: Gemini.Tools.Registry`. This is crucial for creating a stable, discoverable endpoint for tool registration and execution.
    *   Update `gemini/application.ex` to start `Gemini.Supervisor` instead of starting the `UnifiedManager` directly.

2.  **Create the `Gemini.Tools` Facade:**
    *   Create a new file at `gemini/tools.ex` for the `Gemini.Tools` module.
    *   Implement `register(declaration, fun)`: This function is a simple facade that calls `Altar.LATER.Registry.register_tool/3` using the registered name `Gemini.Tools.Registry`.
    *   Implement `execute_calls(function_calls)`: This function takes a list of `%FunctionCall{}` structs. It must use a `Task.async_stream` to execute them in parallel, calling `Altar.LATER.Executor.execute_tool(Gemini.Tools.Registry, call)` for each one. It must handle both success and error results from the tasks and return a list of `Altar.ADM.ToolResult` structs.

3.  **Formalize Chat History Management:**
    *   Create a new file at `gemini/chat.ex` for the `Gemini.Chat` module.
    *   Define a `Gemini.Chat` struct that contains `history: [Gemini.Types.Content.t()]` and any other relevant options (model, generation_config, etc.).
    *   Implement `new(opts \\ [])` to create a chat session.
    *   Implement `add_turn(chat, role, message)`: This function will take a chat struct, a role (`"user"`, `"model"`), and a message (which can be a string, a list of parts, a list of `FunctionCall`s, or a list of `ToolResult`s). It must correctly construct the appropriate `Gemini.Types.Content` struct and append it to the history, returning a **new, updated chat struct**.
    *   Refactor the public `Gemini.chat/1` and `Gemini.send_message/2` functions in `gemini.ex` to use this new, robust `Gemini.Chat` module for their state management.

4.  **Write Integration Tests:** Create a new test file `test/gemini/tools_manual_loop_test.exs`.
    *   In a `setup` block, define a simple tool function and use `Gemini.Tools.register/2` to register it.
    *   Write a single, comprehensive test named `"completes a full manual tool-calling loop"` that performs the following steps sequentially:
        1.  Create a new chat session with `Gemini.Chat.new/1`.
        2.  Add a user turn with a prompt designed to trigger the tool.
        3.  Call `Gemini.generate_content/2` with the chat's history.
        4.  Assert that the response contains the expected `FunctionCall`.
        5.  Add the model's turn (containing the `FunctionCall`) to the chat history.
        6.  Pass the `FunctionCall` list to `Gemini.Tools.execute_calls/1`.
        7.  Assert that you receive the correct `ToolResult`.
        8.  Add the tool's turn (containing the `ToolResult`) to the chat history.
        9.  Call `Gemini.generate_content/2` a final time with the complete, updated history.
        10. Assert that the final response is a text answer that correctly uses the information from the tool's result.
