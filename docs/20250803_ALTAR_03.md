Excellent. This is a fantastic direction. Moving beyond a simple implementation detail (`snakepit`'s bridge) to defining a formal, open, and enterprise-grade protocol is the right next step for creating a truly foundational piece of technology.

Drawing inspiration from your project list's themes of foundation, orchestration, and security, let's craft the specification for a new protocol.

The name needs to be evocative, memorable, and reflective of the Elixir community's ethos of building solid, reliable systems. It should sound like a central, trusted place of exchange.

Let's call it **Altar**.

An altar is a focal point for communication, offerings, and powerful invocations. It's a place where disparate entities meet for a shared purpose. This fits the "MCP" and "A2A" vision perfectly.

---

### **Specification Requirements for Altar: The Agent & Tool Arbitration Protocol (A2A-TP)**

#### **1. Vision & Principles**

*   **Name**: Altar Protocol
*   **Acronym**: A2A-TP (Agent & Tool Arbitration Protocol)
*   **Vision**: To be the industry standard, language-agnostic protocol for enabling secure, observable, and stateful interoperability between autonomous agents, AI models, and traditional software systems. Altar is the "Master Control Program" for enterprise tool integration.
*   **License**: MIT License (100% Open Source)
*   **Guiding Principles**:
    1.  **Transport-Agnostic**: The specification shall define message schemas and interaction patterns, not the underlying transport (e.g., TCP, WebSockets, message queues). Implementations are free to choose the best transport for their use case.
    2.  **Language-Agnostic**: The protocol must be implementable in any modern programming language, with a clear and minimal set of primitive types.
    3.  **Stateful by Design**: Sessions are a first-class citizen, providing a robust mechanism for isolating state, managing resources, and ensuring context continuity.
    4.  **Discoverability is Key**: Runtimes and tools must be dynamically discoverable, allowing for flexible and resilient systems.
    5.  **Observability is Built-in**: Every invocation and result must carry metadata (e.g., invocation IDs, timestamps, execution metrics) to enable seamless tracing, logging, and monitoring.
    6.  **Secure by Default**: The protocol will include clear extension points for authentication, authorization, and resource sandboxing.

---

#### **2. Core Concepts & Terminology**

The Altar specification will formally define the following core entities:

*   **Host**: The central process that implements the Altar protocol and orchestrates communication. In our current context, this is the Elixir/BEAM application.
*   **Runtime**: Any external process that connects to the Host to offer or consume tools. A Python process running `snakepit_bridge` is a Runtime.
*   **Session**: A stateful, isolated context for a series of interactions. A Session has a unique ID and serves as the primary scope for tool registration and state.
*   **Tool Definition**: A declarative schema describing a capability offered by a Runtime. It includes the tool's name, description, parameters, and metadata.
*   **Parameter Schema**: A structured definition of a tool's input parameters, based on a simplified, cross-language type system.
*   **Invocation**: A request from a client (e.g., the Host, an LLM, another agent) to execute a specific tool within a session. Every Invocation has a unique ID for tracking.
*   **Result**: The outcome of a Tool Invocation, which can be a success with a payload or a structured error.
*   **Stream**: A sequence of `Chunks` associated with a single Invocation, used for long-running or progressive results.

---

#### **3. Required Protocol Primitives (Message Schemas)**

The specification must define the structure of the following messages. The format will be abstract (like a struct definition), not tied to JSON or Protobuf.

**3.1. Handshake & Registration**

*   `AnnounceRuntime`: Sent by a Runtime when it connects to the Host.
    *   `runtime_id`: A unique identifier for the Runtime instance.
    *   `language`: e.g., "python", "elixir", "go".
    *   `version`: Version of the Runtime's bridge implementation.
    *   `capabilities`: List of Altar features it supports (e.g., `streaming`, `state_management`).
*   `RegisterTools`: Sent by a Runtime to declare the tools it provides for a given session.
    *   `session_id`: The session to which these tools belong.
    *   `tools`: A list of `Tool Definition` schemas.

**3.2. Invocation & Results**

*   `ToolCall`: The message to invoke a tool.
    *   `invocation_id`: A unique UUID for this specific call, used for correlation.
    *   `session_id`: The session context for the call.
    *   `tool_name`: The fully qualified name of the tool to execute.
    *   `parameters`: A map of parameter names to their values.
    *   `metadata`: Caller-provided metadata for tracing.
*   `ToolResult`: The message for a synchronous or final streaming result.
    *   `invocation_id`: Correlates with the `ToolCall`.
    *   `status`: `success` or `error`.
    *   `payload`: The return value of the tool (if successful). The type must be defined by the `Tool Definition`.
    *   `error_details`: A structured error object (if status is `error`).
    *   `runtime_metadata`: Execution time, resource usage, etc., provided by the Runtime.
*   `StreamChunk`: A message for a piece of a streaming result.
    *   `invocation_id`: Correlates with the `ToolCall`.
    *   `chunk_id`: A sequential identifier for ordering chunks.
    *   `payload`: The partial data for this chunk.
    *   `is_final`: A boolean flag indicating the end of the stream. The final chunk may or may not contain a payload.

**3.3. Session Management**

*   `CreateSession`: A request to establish a new session.
    *   `session_id` (optional): A client-suggested ID. The Host can override it.
    *   `metadata`: Initial metadata for the session.
    *   `ttl_seconds` (optional): A requested time-to-live for the session.
*   `DestroySession`: A request to terminate a session and release its resources.
    *   `session_id`: The ID of the session to destroy.

---

#### **4. Altar Type System**

The specification must define a minimal, unambiguous type system for tool parameters to ensure cross-language compatibility.

*   **Primitives**:
    *   `string`: UTF-8 string.
    *   `integer`: 64-bit signed integer.
    *   `float`: 64-bit IEEE 754 floating-point number.
    *   `boolean`: True or false.
    *   `binary`: Raw byte array for arbitrary binary data.
*   **Complex Types**:
    *   `array`: An ordered list of values of a single specified subtype (e.g., `array[string]`).
    *   `object`: A map of string keys to values of specified types, essentially a nested schema.
*   **Parameter Definition Schema**:
    *   `name`: `string`
    *   `type`: One of the Altar types (`string`, `array[integer]`, etc.).
    *   `description`: `string`
    *   `required`: `boolean`

---

#### **5. Core Interaction Flows (Requirements)**

The spec must detail the sequence of messages for these key scenarios:

1.  **Runtime Initialization**: The sequence for a new Runtime connecting, announcing itself, and the Host acknowledging it.
2.  **Session-Scoped Tool Registration**: The flow where a client requests a new session, and a Runtime registers a set of tools specifically for that session.
3.  **Synchronous Tool Invocation**: The `ToolCall` -> `ToolResult` request/response pattern.
4.  **Streaming Tool Invocation**: The `ToolCall` -> `StreamChunk` (xN) pattern, ending with `is_final: true`.
5.  **Error Handling**: How errors (e.g., tool not found, invalid parameters, execution failure) are represented in `ToolResult` messages.

---

#### **6. Future Considerations (To Be Included in the Spec Outline)**

*   **Security Model**: A dedicated section outlining how implementations can integrate authentication (for Runtimes) and authorization (for tool calls within a session).
*   **State Management Protocol**: While Altar focuses on tools, it should define an optional, complementary protocol for managing shared, typed variables within a session (evolving `snakepit`'s variable bridge).
*   **Tool Orchestration**: Define patterns for how tools can invoke other tools, including how invocation metadata and security contexts are propagated.
*   **Bidirectional Communication**: Specify how a Runtime can initiate a `ToolCall` to the Host or another Runtime, enabling true peer-to-peer agent communication arbitrated by the Host.
