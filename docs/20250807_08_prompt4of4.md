### **Prompt 4 of 4: The Automatic Execution Loop**

**Objective:** Implement the high-level "automatic" tool execution feature that hides the complexity of the multi-turn tool-calling process from the end-user. This orchestration must be implemented for both standard (blocking) and streaming requests, providing a seamless, Python-SDK-like experience.

**Required Reading (CRITICAL):**

1.  **Context Document - `docs/20250807_01_genai_tool_calling_analysis.md`**:
    *   Review **Section 4: Automatic Function Calling Requirements**. This is the behavioral specification you must implement. Pay close attention to the orchestration steps (4.2) and the requirement for streaming support (4.3).

2.  **Context Document - `docs/20250807_03_alter_and_later_initial_impl.md`**:
    *   Read **Stage 3: Automatic Loop (The Concurrency & State Challenge)**. This document outlines the key architectural challenges and decisions.
    *   **Sub-Task 3.1: The Orchestrator:** You will implement the standard (non-streaming) loop using a dedicated, private, recursive helper function as a state machine.
    *   **Sub-Task 3.2: The Streaming Nightmare Re-architected:** You must follow this detailed plan for modifying the `UnifiedManager`. It is not a simple patch; it requires a new "Orchestrator" process to manage the complex, multi-stage stream.

3.  **Gemini Codebase (`./`)**:
    *   `gemini.ex`: You will be adding the new high-level public API functions here.
    *   `gemini/streaming/unified_manager.ex`: This GenServer is the primary focus for the streaming implementation. You will be significantly refactoring its internal logic to support the tool-calling state machine.
    *   `gemini/tools.ex`: You will use the `Gemini.Tools.execute_calls/1` function you built in the previous stage.
    *   `gemini/chat.ex`: You will use the `Gemini.Chat` module to manage the history throughout the automated loop.

**Agent Directive:**

**Part A: Standard (Non-Streaming) Automatic Loop**

1.  **Create the Public API:**
    *   In `gemini.ex`, create a new function `generate_content_with_auto_tools(contents, opts)`.
    *   This function will be the public entry point. It will prepare the initial `Gemini.Chat` state and then delegate to a private orchestrator function.
2.  **Implement the Orchestrator:**
    *   Inside the `Gemini` module, create a private helper function, e.g., `orchestrate_tool_loop(chat, turn_limit)`.
    *   This function will implement the recursive state machine:
        a. Make an API call using `Gemini.APIs.Coordinator.generate_content/2` with the current chat history.
        b. Inspect the response. Check the `finish_reason` and the content parts.
        c. **If the response is a text answer (`finish_reason` is not `"TOOL_USE"`):** Return the final response. This is the base case for the recursion.
        d. **If the response contains `function_call` parts:**
            i.   Decrement the `turn_limit`. If the limit is zero, return an error to prevent infinite loops.
            ii.  Add the model's `function_call` turn to the chat history using `Gemini.Chat.add_turn/3`.
            iii. Execute the calls using `Gemini.Tools.execute_calls/1`.
            iv.  Add the user's `function_response` turn to the chat history.
            v.   **Recursively call `orchestrate_tool_loop/2`** with the new, updated chat state.

**Part B: Streaming Automatic Loop (Major Refactoring)**

1.  **Create a New Orchestrator Process:**
    *   Create a new file and module: `gemini/streaming/tool_orchestrator.ex`.
    *   This module will be a GenServer responsible for managing a single, stateful, automatic tool-calling stream.
2.  **Modify `UnifiedManager` to Delegate:**
    *   In `gemini/streaming/unified_manager.ex`, create a new `handle_call` for `{:start_auto_stream, ...}`.
    *   Instead of calling `HTTPStreaming` directly, this handler will now start and supervise a new `Gemini.Streaming.ToolOrchestrator` process, passing it all the necessary context (prompt, tools, subscriber PID, etc.).
    *   The `UnifiedManager` will store the PID of the orchestrator and will proxy all future interactions (like `subscribe` or `stop_stream`) to it.
3.  **Implement the `ToolOrchestrator` GenServer:**
    *   The orchestrator's state (`t()`) must track the current phase of the operation (e.g., `:awaiting_model_call`, `:executing_tools`, `:awaiting_final_response`).
    *   **`init/1`:** On start, it will immediately initiate the **first** streaming HTTP request to the Gemini API. It will stream the results *to itself*.
    *   **`handle_info({:stream_event, ...})`:**
        *   If in the `:awaiting_model_call` state, it will buffer the incoming chunks and inspect them.
        *   When it detects a `function_call` part, it will transition its state to `:executing_tools`. It will stop the first HTTP stream.
        *   It will then asynchronously call `Gemini.Tools.execute_calls/1`.
    *   **On tool execution completion:**
        *   It transitions state to `:awaiting_final_response`.
        *   It constructs the `FunctionResponse` content.
        *   It initiates the **second** streaming HTTP request to the Gemini API with the full history.
        *   It begins streaming the results of this *second* request to the original end-user's subscriber PID.
    *   **`handle_info` for the second stream:** It will simply proxy these events (`:stream_event`, `:stream_complete`, `:stream_error`) to all subscribers.
    *   Implement robust cleanup and error handling for all states. If tool execution fails, it must send a `:stream_error` to the subscriber.

**Part C: Testing**

1.  **Create `test/gemini_auto_tools_test.exs`:**
    *   Write a test for the standard `generate_content_with_auto_tools/2` function. It should register a tool, call the function, and assert that it receives the correct final text answer in a single step.
    *   Test the `turn_limit` functionality, asserting that the loop errors out correctly if the model keeps trying to call functions.
    *   Write a test for the streaming automatic loop. It should start the stream, subscribe, and collect all the final text chunks. It must assert that no intermediate `function_call` chunks were ever received by the subscriber.

---

This completes the implementation plan. Executing this prompt will result in `gemini_ex` having full, robust, and well-tested feature parity with the official Python SDK's tool-calling capabilities.
