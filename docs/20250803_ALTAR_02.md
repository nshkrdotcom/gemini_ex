### **Contextual File List for `gemini_ex` Tool Implementation**

#### A. Google `genai` Python SDK Files

These files serve as the "source of truth" for the API design, defining the data structures and method signatures that `gemini_ex` should aim to replicate for a consistent developer experience.

1.  **`types.py`**:
    *   **Reason for Inclusion**: This is the most critical file. It defines the Pydantic models for `Tool`, `FunctionDeclaration`, `Schema`, `FunctionCall`, `GenerateContentResponse`, `Candidate`, and `Part`. The new Elixir structs in `Gemini.Types.Tooling` are designed to be direct equivalents of these Python classes.

2.  **`models.py`**:
    *   **Reason for Inclusion**: Contains the primary `generate_content` and `generate_content_stream` methods. This file shows how the `tools` and `tool_config` parameters are used in practice, how responses containing function calls are handled, and the logic for automatic function calling loops. It provides the behavioral context for the entire feature.

3.  **`_automatic_function_calling_util.py`**:
    *   **Reason for Inclusion**: This utility contains the logic for inspecting Python functions and converting them into `FunctionDeclaration` schemas. This is the direct Python equivalent of what the `Gemini.ToolBridge` needs to do when converting a `snakepit` tool spec, making it an invaluable reference.

4.  **`_transformers.py`**:
    *   **Reason for Inclusion**: Contains the `t_tool` transformer function, which processes user-provided tool definitions into the format required by the API. This provides context on how different forms of tool definitions (e.g., callables, dicts) are normalized before being sent in a request.

5.  **`chats.py`**:
    *   **Reason for Inclusion**: Demonstrates how tool calls and function responses are managed within a multi-turn conversation. The design document includes a multi-turn example, and this file shows the canonical implementation of that state management.

#### B. `snakepit/lib` Elixir Library Files

These files define the Elixir-side of the `snakepit` bridge, which is the target for our integration. They provide the necessary context for the `Gemini.ToolBridge` to correctly interact with `snakepit`'s tool management system.

1.  **`snakepit/bridge/tool_registry.ex`**:
    *   **Reason for Inclusion**: This is the core integration point. It defines the `Snakepit.Bridge.InternalToolSpec` struct that `Gemini.ToolBridge` must convert. It also contains the GenServer API (`list_tools`, `execute_local_tool`) that the full tool execution loop will interact with.

2.  **`snakepit/bridge/session.ex`**:
    *   **Reason for Inclusion**: Defines the `Session` struct. Since tools in `snakepit` are session-scoped, understanding the session data structure is crucial for implementing a robust integration that correctly handles session state.

3.  **`snakepit/bridge/session_store.ex`**:
    *   **Reason for Inclusion**: Provides the public API for managing sessions. The tool execution loop will need to interact with this to fetch session information and potentially store program/tool state.

4.  **`snakepit/grpc/bridge_server.ex`**:
    *   **Reason for Inclusion**: This is the Elixir gRPC server implementation. It shows how Python workers register their tools via the `RegisterTools` RPC. This provides the context for how the `ToolRegistry` is populated from remote workers.

5.  **`snakepit/grpc/generated/snakepit_bridge.pb.ex`**:
    *   **Reason for Inclusion**: The generated Protobuf code for Elixir. It defines the exact `ToolSpec` and `ParameterSpec` messages that are sent from Python. This is the raw data that the bridge server receives and converts into the `InternalToolSpec`.

6.  **`snakepit.ex`**:
    *   **Reason for Inclusion**: The main public API for `snakepit`. It contains the `execute_in_session` function, which is the primary function used in the design's example workflow to execute a tool on a Python worker.

#### C. `snakepit/priv` Python and Protocol Files

These files show how the Python side of the `snakepit` bridge defines, discovers, and registers its tools. This is the counterpart to the Elixir logic and completes the end-to-end picture.

1.  **`proto/snakepit_bridge.proto`**:
    *   **Reason for Inclusion**: The Protobuf definition file is the canonical contract for the entire gRPC bridge. It defines the `ToolRegistration` message that Python sends and the `BridgeService` RPCs that facilitate communication.

2.  **`python/snakepit_bridge/base_adapter.py`**:
    *   **Reason for Inclusion**: This is the most important Python file for context. It defines the `BaseAdapter` class, the `@tool` decorator, and the `get_tools` method which discovers Python functions and converts them into `ToolRegistration` Protobuf messages. This is the direct source of the data that `Gemini.ToolBridge` will be consuming.

3.  **`python/grpc_server.py`**:
    *   **Reason for Inclusion**: The Python gRPC server implementation. It shows how the server receives calls from Elixir and dispatches them to the adapter's `execute_tool` method. It also shows the `RegisterTools` implementation on the Python side, completing the registration workflow.

4.  **`python/snakepit_bridge/session_context.py`**:
    *   **Reason for Inclusion**: Provides a powerful example of the bridge's capabilities, showing how a Python worker can maintain a stateful context that calls back into Elixir to manage variables and even execute Elixir-defined tools. This demonstrates the bidirectional nature of the bridge.

5.  **`python/snakepit_bridge/adapters/showcase/showcase_adapter.py`**:
    *   **Reason for Inclusion**: A concrete example of an adapter implementation. It shows how various Python functions (with different signatures and purposes) are exposed as tools, providing a practical reference for how `snakepit` tools look in the wild.
