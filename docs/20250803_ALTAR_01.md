### **Design Document: Gemini Tool Integration**

#### 1. Overview

This document outlines the design for adding Tool Calling functionality to the `gemini_ex` Elixir library. The primary goals are:

1.  **Achieve Parity:** Implement a tool definition and execution flow that aligns with the official Google `genai` Python SDK, as requested in the issue.
2.  **Seamless Integration:** Provide a bridge to integrate with `snakepit`'s tool registry, allowing `gemini_ex` to use tools defined in remote Python workers.
3.  **Extensibility:** Create a foundation that can support various tool types (Function Calling, Google Search, etc.) and is maintainable.

The design is split into two main parts: core feature implementation within `gemini_ex` and the integration layer for `snakepit`.

---

#### 2. Core `gemini_ex` Feature Design

This section details the necessary changes within the `gemini_ex` library to support tool calling natively.

##### 2.1. New Data Structures

To represent tools and their components in a structured way, a new module `Gemini.Types.Tooling` will be created. It will contain the following structs:

**`lib/gemini/types/tooling.ex` (New File)**

```elixir
defmodule Gemini.Types.Tooling do
  @moduledoc "Structs for Gemini tool definitions and calls."
  
  alias __MODULE__.{FunctionDeclaration, GoogleSearch, Schema, FunctionCall, FunctionResponse}

  defmodule Tool do
    @moduledoc "A collection of tools that the model can use."
    use TypedStruct

    typedstruct do
      field :function_declarations, [FunctionDeclaration.t()], default: []
      field :google_search, GoogleSearch.t() | nil, default: nil
      # Other tool types like Retrieval can be added here later.
    end
  end

  defmodule GoogleSearch do
    @moduledoc "A tool that executes a Google search."
    use TypedStruct
    typedstruct do
      # This struct is a marker and has no fields, matching the Python SDK.
    end
  end

  defmodule Schema do
    @moduledoc "Represents a subset of the OpenAPI 3.0 schema object."
    use TypedStruct

    typedstruct do
      field :type, atom(), enforce: true # :OBJECT, :STRING, :NUMBER, :INTEGER, :BOOLEAN, :ARRAY
      field :description, String.t() | nil, default: nil
      field :format, String.t() | nil, default: nil
      field :enum, [String.t()] | nil, default: nil
      field :properties, %{String.t() => __MODULE__.t()} | nil, default: nil
      field :required, [String.t()] | nil, default: nil
      field :items, __MODULE__.t() | nil, default: nil
    end
  end

  defmodule FunctionDeclaration do
    @moduledoc "Structured representation of a function declaration."
    use TypedStruct

    typedstruct do
      field :name, String.t(), enforce: true
      field :description, String.t(), enforce: true
      field :parameters, Schema.t() | nil, default: nil
    end
  end

  defmodule FunctionCall do
    @moduledoc "A function call predicted by the model."
    use TypedStruct
    typedstruct do
      field :name, String.t(), enforce: true
      field :args, map(), default: %{}
    end
  end

  defmodule FunctionResponse do
    @moduledoc "The result of a function call."
    use TypedStruct
    typedstruct do
      field :name, String.t(), enforce: true
      field :response, map(), enforce: true
    end
  end
end
```

##### 2.2. `Part` Struct Modification

The `Gemini.Types.Part` struct must be extended to carry tool-related content.

**`lib/gemini/types/common/part.ex` (Modified)**

```elixir
defmodule Gemini.Types.Part do
  # ... existing code ...
  alias Gemini.Types.Tooling.{FunctionCall, FunctionResponse}

  typedstruct do
    field(:text, String.t() | nil, default: nil)
    field(:inline_data, Gemini.Types.Blob.t() | nil, default: nil)
    # New fields for tool calls and responses
    field(:function_call, FunctionCall.t() | nil, default: nil)
    field(:function_response, FunctionResponse.t() | nil, default: nil)
  end

  # ... existing functions ...

  @doc "Create a function call part."
  @spec function_call(String.t(), map()) :: t()
  def function_call(name, args) do
    %__MODULE__{function_call: %FunctionCall{name: name, args: args}}
  end

  @doc "Create a function response part."
  @spec function_response(String.t(), map()) :: t()
  def function_response(name, response) do
    %__MODULE__{function_response: %FunctionResponse{name: name, response: response}}
  end
end
```

##### 2.3. Request Generation

The `generateContent` request payload needs to include the `tools` field. This will be handled by updating `Gemini.Types.Request.GenerateContentRequest` and the `Gemini.Generate` module.

**`lib/gemini/types/request/generate_content_request.ex` (Modified)**

```elixir
defmodule Gemini.Types.Request.GenerateContentRequest do
  # ... existing code ...
  alias Gemini.Types.Tooling.Tool

  typedstruct do
    # ... existing fields ...
    field(:tools, [Tool.t()], default: []) # Add new field
    # ... existing fields ...
  end
  # ... to_json_map/1 will automatically handle the new field.
end
```

**`lib/gemini/apis/generate.ex` (Modified)**

The `build_generate_request/2` function will now automatically accept and process a `:tools` option.

```elixir
# No change is needed here if GenerateContentRequest is updated correctly.
# The call will look like this:
Gemini.Generate.content("What's the weather in Boston?",
  tools: [
    %Gemini.Types.Tooling.Tool{
      function_declarations: [%Gemini.Types.Tooling.FunctionDeclaration{...}]
    }
  ]
)
```

The `Coordinator` module will also need to be updated to convert the `Tool` structs to the camelCase map format required by the API.

##### 2.4. Response Handling

The response parsing logic must be updated to recognize and handle `functionCall` parts from the API.

**`lib/gemini/apis/generate.ex` (Modified `parse_content` helper)**

```elixir
defp parse_content(content_data) do
  parts =
    content_data
    |> Map.get("parts", [])
    |> Enum.map(fn part_data ->
      cond do
        Map.has_key?(part_data, "text") ->
          Part.text(Map.get(part_data, "text"))

        Map.has_key?(part_data, "inlineData") ->
          # ... existing inlineData logic ...

        # New clause for function calls
        Map.has_key?(part_data, "functionCall") ->
          call_data = Map.get(part_data, "functionCall")
          Part.function_call(Map.get(call_data, "name"), Map.get(call_data, "args"))

        true ->
          # Fallback
          Part.text("")
      end
    end)
  # ... rest of the function ...
end
```

---

#### 3. Snakepit Tool Bridge Integration

To bridge the gap between `gemini_ex` and `snakepit`, a new integration module will be created. This allows tools registered in `snakepit` (potentially from Python workers) to be seamlessly passed to the Gemini API.

##### 3.1. New Module: `Gemini.ToolBridge`

This module will contain functions for converting between `snakepit` tool specifications and `gemini_ex` tool structs.

**`lib/gemini/tool_bridge.ex` (New File)**

```elixir
defmodule Gemini.ToolBridge do
  @moduledoc "Provides integration between gemini_ex tools and the snakepit tool bridge."

  alias Gemini.Types.Tooling.{Tool, FunctionDeclaration, Schema}
  alias Snakepit.Bridge.ToolRegistry

  @doc """
  Fetches all tools from a snakepit session and converts them for Gemini.
  """
  @spec get_tools_for_gemini(String.t()) :: {:ok, [Tool.t()]} | {:error, any}
  def get_tools_for_gemini(session_id) do
    tools =
      session_id
      |> ToolRegistry.list_tools()
      |> Enum.map(&from_snakepit_tool/1)

    {:ok, tools}
  end

  @doc """
  Converts a Snakepit tool specification into a Gemini Tool struct.
  """
  def from_snakepit_tool(%Snakepit.Bridge.InternalToolSpec{} = spec) do
    gemini_schema = convert_params_to_schema(spec.parameters)

    func_decl = %FunctionDeclaration{
      name: spec.name,
      description: spec.description,
      parameters: gemini_schema
    }

    %Tool{function_declarations: [func_decl]}
  end

  defp convert_params_to_schema(params) when is_list(params) do
    properties =
      Map.new(params, fn p ->
        # Convert snakepit param type to Gemini schema type
        schema_type_atom = String.to_atom(p.type)
        prop_schema = %Schema{type: schema_type_atom, description: p.description}
        {p.name, prop_schema}
      end)

    required =
      params
      |> Enum.filter(& &1.required)
      |> Enum.map(& &1.name)

    %Schema{
      type: :OBJECT,
      properties: properties,
      required: required
    }
  end
end
```

##### 3.2. Example Workflow

Here is the end-to-end workflow leveraging this integration:

1.  **Tool Definition (Python):** A developer defines a function in a Python worker.
    ```python
    # In a snakepit python worker
    def get_current_weather(location: str, unit: str = "celsius"):
        """Gets the current weather for a given location."""
        # ... implementation ...
    ```

2.  **Tool Registration (`snakepit`):** On startup, the `snakepit` Python worker inspects the function and registers it with the `ToolRegistry` on the Elixir side.

3.  **Tool Conversion (`gemini_ex`):** The Elixir application fetches and converts the registered tools.
    ```elixir
    session_id = "user_123"
    {:ok, gemini_tools} = Gemini.ToolBridge.get_tools_for_gemini(session_id)
    ```

4.  **API Call (`gemini_ex`):** The application makes a call to Gemini, providing the converted tools.
    ```elixir
    prompt = "What's the weather like in Boston?"
    {:ok, response} = Gemini.generate(prompt, tools: gemini_tools)
    ```

5.  **Model Response:** Gemini responds with a `function_call` part.
    ```elixir
    # response.candidates |> List.first() |> Map.get(:content) |> Map.get(:parts)
    [
      %Gemini.Types.Part{
        function_call: %Gemini.Types.Tooling.FunctionCall{
          name: "get_current_weather",
          args: %{"location" => "Boston, MA"}
        },
        ...
      }
    ]
    ```

6.  **Tool Execution (`snakepit`):** The application uses `snakepit` to execute the requested function on the Python worker.
    ```elixir
    %Gemini.Types.Part{function_call: call} = function_call_part
    {:ok, result} = Snakepit.execute_in_session(session_id, call.name, call.args)
    # result -> %{"temperature" => "22", "unit" => "celsius", "forecast" => "windy"}
    ```

7.  **Follow-up API Call:** The application sends the tool's result back to Gemini to get a final, human-readable answer.
    ```elixir
    # Create conversation history with the function call and response
    history = [
      Content.text(prompt, "user"),
      Content.new(role: "model", parts: [function_call_part]),
      Content.new(role: "user", parts: [Part.function_response(call.name, %{result: result})])
    ]
    {:ok, final_response} = Gemini.generate(history)
    # final_response.text -> "The current weather in Boston is 22Â°C and windy."
    ```

---

#### 4. Implementation Plan

The implementation will involve the following file changes:

1.  **Create `lib/gemini/types/tooling.ex`:** Define the new data structures for tools.
2.  **Create `lib/gemini/tool_bridge.ex`:** Implement the conversion logic for `snakepit` integration.
3.  **Modify `lib/gemini/types/common/part.ex`:** Add `function_call` and `function_response` fields and helper functions.
4.  **Modify `lib/gemini/types/request/generate_content_request.ex`:** Add the `:tools` field to the request struct.
5.  **Modify `lib/gemini/apis/generate.ex`:** Update the response parsing logic to handle `functionCall` parts.
6.  **Modify `lib/gemini/apis/coordinator.ex`:** Ensure the `tools` option is correctly passed through and serialized into the API request map with camelCase keys.
