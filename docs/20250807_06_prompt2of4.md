### **Prompt 2 of 4: Deserialization and the Manual Loop Foundation**

**Objective:** With the ability to send tool definitions, we must now be able to receive and understand the model's response when it asks us to call a function. You will update the response parsing logic to recognize `functionCall` parts and build the necessary serializers to construct a valid `functionResponse` part to send back to the model. This prompt establishes the complete data contract for a multi-turn tool-calling loop.

**Required Reading (CRITICAL):**

1.  **Context Document - `docs/20250807_01_genai_tool_calling_analysis.md`**:
    *   Review **Section 3.2: Model to User (Function Call)** to understand the structure of the incoming `functionCall` object.
    *   Review **Section 3.3: User to Model (Function Response)** to understand the precise JSON structure you must create to send the tool's results back to the API. Note the nesting: `Content -> Part -> functionResponse -> {name, response: {content}}`.

2.  **Context Document - `docs/20250807_03_alter_and_later_initial_impl.md`**:
    *   Read **Sub-Task 1.2: Advanced Response Deserialization & Validation**. This section details the challenge: `functionCall` is not a top-level field but a *type of part*. It also defines the critical error handling strategy for when the model returns a malformed `functionCall`. You must implement this.
    *   Read **Sub-Task 2.3: `Content.from_tool_results` - The Other Serializer**. This explains the challenge of serializing `ToolResult` structs into the `functionResponse` format.

3.  **ALTAR Codebase (`./ALTER/`)**:
    *   `lib/altar/adm/function_call.ex`: Review the struct definition (lines 9-12) and the `new/1` constructor (lines 24-38). Your parsing logic will call this function.
    *   `lib/altar/adm/tool_result.ex`: Review the struct definition (lines 10-13). This is the data you will be transforming into a `functionResponse`.

4.  **Gemini Codebase (`./`)**:
    *   `gemini/types/common/part.ex`: This is the primary file you will modify. Review the existing `typedstruct` (lines 7-11).
    *   `gemini/apis/generate.ex`: Locate the `parse_candidate` (line 218) and `parse_content` (line 241) helper functions. You will modify `parse_content` or a new helper it calls to handle the `functionCall` part type.
    *   `gemini/types/common/content.ex`: You will be adding a new public constructor function to this module.

**Agent Directive:**

1.  **Update `Part` Struct:** In `gemini/types/common/part.ex`, add a new field to the `typedstruct`:
    *   `field(:function_call, Altar.ADM.FunctionCall.t() | nil, default: nil)`

2.  **Update Response Parser:**
    *   In `gemini/apis/generate.ex`, modify the `parse_content` function (or a helper function it calls) to handle parts containing a `functionCall`.
    *   When a part map from the API contains a `"functionCall"` key, you must pass its value (which will be a map with string keys) to `Altar.ADM.FunctionCall.new/1`.
    *   **Implement the mandatory error handling:**
        *   If `FunctionCall.new/1` returns `{:ok, struct}`, populate the `function_call` field of the `Part` struct you are creating.
        *   If `FunctionCall.new/1` returns `{:error, reason}`, you must stop parsing and cause the entire `parse_generate_response` function to fail with `{:error, %Gemini.Error{type: :invalid_response, message: "Model returned malformed FunctionCall: #{reason}"}}`. This ensures the client never receives a partially parsed or invalid response.

3.  **Create Tool Result Serializer:**
    *   In `gemini/types/common/content.ex`, create a new public function: `from_tool_results(results :: [Altar.ADM.ToolResult.t()])`.
    *   This function must take a list of validated `ToolResult` structs.
    *   It must transform them into a single `Content` struct with `role: "tool"`.
    *   The `parts` of this `Content` struct must be a list of maps, with each map having the structure `%{functionResponse: %{name: result.call_id, response: %{content: result.content}}}`. You must use the `call_id` from the `ToolResult` as the `name` in the `functionResponse`, as required by the Gemini API.

4.  **Write Tests:** Create a new test file, `test/gemini/apis/generate_parsing_test.exs`.
    *   **Deserialization:**
        *   Create a test that parses a mock API response JSON containing a valid `functionCall` and asserts that the correct, validated `Altar.ADM.FunctionCall` struct is present in the final `GenerateContentResponse.candidates.content.parts`.
        *   Create a test that parses a mock API response with a *malformed* `functionCall` (e.g., missing `"name"`) and asserts that the top-level parsing function correctly returns an `{:error, %Gemini.Error{type: :invalid_response, ...}}` tuple.
    *   **Serialization:**
        *   Create a test for the `Content.from_tool_results/1` function.
        *   Pass it a list of mock `ToolResult` structs and assert that the resulting `Content` struct has the exact structure, role, and nested part format specified in **`docs/20250807_01_genai_tool_calling_analysis.md` (Section 3.3)**.
