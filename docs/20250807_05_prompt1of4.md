### **Prompt 1 of 4: Foundational Integration - The Data Contract & Serialization**

**Objective:** This first stage is the most critical. You will integrate the `ALTAR` Data Model (`ADM`) into the `gemini_ex` library. This involves making `gemini_ex` "bilingual"â€”able to speak both its own internal types and the universal `ADM` contract, and correctly serialize `ADM` structs into the precise JSON the Gemini API expects.

**Required Reading (CRITICAL):**

1.  **Context Document - `docs/20250807_01_genai_tool_calling_analysis.md`**:
    *   Review **Section 1: Tool & Function Declaration Requirements** to understand the target JSON structure for `Tool`, `FunctionDeclaration`, and the OpenAPI Schema for `parameters`.
    *   Review **Section 2: Tool Configuration & Execution Control Requirements** to understand the target JSON for `ToolConfig`.

2.  **Context Document - `docs/20250807_03_alter_and_later_initial_impl.md`**:
    *   Read **Sub-Task 1.1: Deep `ADM` Integration & Serialization**. This highlights the key challenge you must solve: converting `snake_case` Elixir atoms from `ALTAR` structs into `camelCase` string keys for the JSON payload. The decision to use explicit conversion functions over custom encoders is the strategy you will follow.

3.  **ALTAR Codebase (`./ALTER/`)**:
    *   `lib/altar/adm/function_declaration.ex`: Pay close attention to the struct definition (lines 20-23) and the typespec (lines 29-34). This is the source data you will be transforming.
    *   `lib/altar/adm/tool_config.ex`: Review the struct definition (lines 16-18) and typespec (lines 24-28).
    *   `priv/docs/specs/01-data-model/README.md`: Skim **Section 4.2.4 & 4.3.5** to see the target JSON Schema representation for `FunctionDeclaration` and `Schema`. Your output must be compatible with this.

4.  **Gemini Codebase (`./`)**:
    *   `gemini/types/request/generate_content_request.ex`: Understand the existing struct (lines 14-23). You will be adding `tools` and `tool_config` fields.
    *   `gemini/apis/coordinator.ex`: Specifically the `build_generate_request` function (lines 222-263). This is the primary function you will modify to inject the new serialization logic.

**Agent Directive:**

1.  **Add Dependency:** Add `{:altar, path: "./ALTER"}` to the `deps` function in `mix.exs`.
2.  **Create Serialization Module:** Create a new file at `gemini/types/tool_serialization.ex` for a module named `Gemini.Types.ToolSerialization`. This module will contain pure functions for data transformation.
    *   Implement `to_api_tool_list(declarations :: [Altar.ADM.FunctionDeclaration.t()]) :: [map()]`. This function must take the `ADM` structs and produce a list of maps with `camelCase` string keys, precisely matching the format specified in **`docs/20250807_01_genai_tool_calling_analysis.md` (Section 1.2)**. The final list should be suitable to be placed under a `"tools"` key in the API request.
    *   Implement `to_api_tool_config(config :: Altar.ADM.ToolConfig.t()) :: map()`. This must produce a map like `%{functionCallingConfig: %{mode: "AUTO", allowedFunctionNames: [...]}}`.
3.  **Update `GenerateContentRequest`:** In `gemini/types/request/generate_content_request.ex`:
    *   Add the following fields to the `typedstruct`:
        *   `field(:tools, [map()], default: [])`
        *   `field(:tool_config, map() | nil, default: nil)`
4.  **Update Request Builder:** In `gemini/apis/coordinator.ex`, modify the `build_generate_request` function.
    *   It must now accept `:tools` (a list of `Altar.ADM.FunctionDeclaration.t()`) and `:tool_config` (an `Altar.ADM.ToolConfig.t()`) in its `opts`.
    *   If these options are present, it must use your new `Gemini.Types.ToolSerialization` module to convert the `ADM` structs.
    *   The resulting maps must be added to the request payload under the keys `"tools"` and `"toolConfig"`.
5.  **Write Tests:** Create a new test file, `test/gemini/types/tool_serialization_test.exs`.
    *   Assert that `to_api_tool_list/1` correctly transforms `snake_case` atoms to `camelCase` strings and handles the structure of the `parameters` schema.
    *   Assert that `to_api_tool_config/1` correctly nests the config inside `%{functionCallingConfig: ...}`.
    *   These tests are critical for preventing silent API errors due to malformed JSON.
