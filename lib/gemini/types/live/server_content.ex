defmodule Gemini.Types.Live.ServerContent do
  @moduledoc """
  Server content message for Live API sessions.

  Incremental server update generated by the model in response to client
  messages. Content is generated as quickly as possible, not in real time.
  Clients may choose to buffer and play it out in real time.

  ## Fields

  - `model_turn` - Content generated by the model as part of the conversation
  - `generation_complete` - True if the model is done generating
  - `turn_complete` - True if the model has completed its turn
  - `interrupted` - True if a client message interrupted model generation
  - `grounding_metadata` - Grounding metadata for the generated content
  - `input_transcription` - Transcription of input audio
  - `output_transcription` - Transcription of model's audio output
  - `url_context_metadata` - Metadata from URL context retrieval

  ## Example

      %ServerContent{
        model_turn: %{role: "model", parts: [%{text: "Hello!"}]},
        turn_complete: true
      }
  """

  alias Gemini.Types.Live.{GroundingMetadata, Transcription}

  @type content :: %{
          optional(:role) => String.t(),
          optional(:parts) => [map()]
        }

  @type url_context_metadata :: %{
          optional(:url_metadata) => [map()]
        }

  @type t :: %__MODULE__{
          model_turn: content() | nil,
          generation_complete: boolean() | nil,
          turn_complete: boolean() | nil,
          interrupted: boolean() | nil,
          grounding_metadata: GroundingMetadata.t() | nil,
          input_transcription: Transcription.t() | nil,
          output_transcription: Transcription.t() | nil,
          url_context_metadata: url_context_metadata() | nil
        }

  defstruct [
    :model_turn,
    :generation_complete,
    :turn_complete,
    :interrupted,
    :grounding_metadata,
    :input_transcription,
    :output_transcription,
    :url_context_metadata
  ]

  @doc """
  Creates a new ServerContent.
  """
  @spec new(keyword()) :: t()
  def new(opts \\ []) do
    %__MODULE__{
      model_turn: Keyword.get(opts, :model_turn),
      generation_complete: Keyword.get(opts, :generation_complete),
      turn_complete: Keyword.get(opts, :turn_complete),
      interrupted: Keyword.get(opts, :interrupted),
      grounding_metadata: Keyword.get(opts, :grounding_metadata),
      input_transcription: Keyword.get(opts, :input_transcription),
      output_transcription: Keyword.get(opts, :output_transcription),
      url_context_metadata: Keyword.get(opts, :url_context_metadata)
    }
  end

  @doc """
  Converts to API format (camelCase).
  """
  @spec to_api(t() | nil) :: map() | nil
  def to_api(nil), do: nil

  def to_api(%__MODULE__{} = value) do
    %{}
    |> maybe_put("modelTurn", convert_content_to_api(value.model_turn))
    |> maybe_put("generationComplete", value.generation_complete)
    |> maybe_put("turnComplete", value.turn_complete)
    |> maybe_put("interrupted", value.interrupted)
    |> maybe_put("groundingMetadata", GroundingMetadata.to_api(value.grounding_metadata))
    |> maybe_put("inputTranscription", Transcription.to_api(value.input_transcription))
    |> maybe_put("outputTranscription", Transcription.to_api(value.output_transcription))
    |> maybe_put("urlContextMetadata", convert_url_context_to_api(value.url_context_metadata))
  end

  @doc """
  Parses from API response.
  """
  @spec from_api(map() | nil) :: t() | nil
  def from_api(nil), do: nil

  def from_api(data) when is_map(data) do
    %__MODULE__{
      model_turn: parse_content(data["modelTurn"] || data["model_turn"]),
      generation_complete: data["generationComplete"] || data["generation_complete"],
      turn_complete: data["turnComplete"] || data["turn_complete"],
      interrupted: data["interrupted"],
      grounding_metadata:
        (data["groundingMetadata"] || data["grounding_metadata"])
        |> GroundingMetadata.from_api(),
      input_transcription:
        (data["inputTranscription"] || data["input_transcription"])
        |> Transcription.from_api(),
      output_transcription:
        (data["outputTranscription"] || data["output_transcription"])
        |> Transcription.from_api(),
      url_context_metadata:
        parse_url_context(data["urlContextMetadata"] || data["url_context_metadata"])
    }
  end

  @doc """
  Extracts text from the model turn.
  """
  @spec extract_text(t()) :: String.t() | nil
  def extract_text(%__MODULE__{model_turn: nil}), do: nil

  def extract_text(%__MODULE__{model_turn: %{parts: parts}}) when is_list(parts) do
    parts
    |> Enum.map(fn part -> part[:text] || part["text"] end)
    |> Enum.reject(&is_nil/1)
    |> Enum.join("")
  end

  def extract_text(_), do: nil

  defp convert_content_to_api(nil), do: nil

  defp convert_content_to_api(%{role: role, parts: parts}) do
    %{
      "role" => role,
      "parts" => convert_parts_to_api(parts)
    }
  end

  defp convert_content_to_api(other), do: other

  defp convert_parts_to_api(parts) when is_list(parts) do
    Enum.map(parts, fn part ->
      %{}
      |> maybe_put("text", part[:text] || part["text"])
      |> maybe_put("inlineData", part[:inline_data] || part["inlineData"])
      |> maybe_put("functionCall", part[:function_call] || part["functionCall"])
      |> maybe_put("functionResponse", part[:function_response] || part["functionResponse"])
    end)
  end

  defp convert_parts_to_api(other), do: other

  defp convert_url_context_to_api(nil), do: nil

  defp convert_url_context_to_api(%{url_metadata: metadata}) do
    %{"urlMetadata" => metadata}
  end

  defp convert_url_context_to_api(other), do: other

  defp parse_content(nil), do: nil

  defp parse_content(data) when is_map(data) do
    %{
      role: data["role"],
      parts: parse_parts(data["parts"])
    }
  end

  defp parse_parts(nil), do: nil

  defp parse_parts(parts) when is_list(parts) do
    Enum.map(parts, fn part ->
      %{
        text: part["text"],
        inline_data: part["inlineData"],
        function_call: part["functionCall"],
        function_response: part["functionResponse"]
      }
      |> Enum.reject(fn {_k, v} -> is_nil(v) end)
      |> Enum.into(%{})
    end)
  end

  defp parse_url_context(nil), do: nil

  defp parse_url_context(data) when is_map(data) do
    %{
      url_metadata: data["urlMetadata"] || data["url_metadata"]
    }
  end

  defp maybe_put(map, _key, nil), do: map
  defp maybe_put(map, key, value), do: Map.put(map, key, value)
end
