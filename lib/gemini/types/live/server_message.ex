defmodule Gemini.Types.Live.ServerMessage do
  @moduledoc """
  Server message wrapper for Live API responses.

  Response message for the BidiGenerateContent call. Contains exactly one
  message type field plus optional usage metadata.

  ## Message Types

  - `setup_complete` - Session setup confirmation
  - `server_content` - Content generated by the model
  - `tool_call` - Request to execute function calls
  - `tool_call_cancellation` - Notification to cancel tool calls
  - `go_away` - Notice that server will disconnect soon
  - `session_resumption_update` - Session resumption state update
  - `voice_activity` - Voice activity detection signal

  ## Example

      # Server content message
      %ServerMessage{
        server_content: %ServerContent{
          model_turn: %{role: "model", parts: [%{text: "Hello!"}]},
          turn_complete: true
        },
        usage_metadata: %UsageMetadata{total_token_count: 100}
      }
  """

  alias Gemini.Types.Live.{
    GoAway,
    ServerContent,
    SessionResumptionUpdate,
    SetupComplete,
    ToolCall,
    ToolCallCancellation,
    UsageMetadata,
    VoiceActivity
  }

  @type t :: %__MODULE__{
          setup_complete: SetupComplete.t() | nil,
          server_content: ServerContent.t() | nil,
          tool_call: ToolCall.t() | nil,
          tool_call_cancellation: ToolCallCancellation.t() | nil,
          go_away: GoAway.t() | nil,
          session_resumption_update: SessionResumptionUpdate.t() | nil,
          voice_activity: VoiceActivity.t() | nil,
          usage_metadata: UsageMetadata.t() | nil
        }

  defstruct [
    :setup_complete,
    :server_content,
    :tool_call,
    :tool_call_cancellation,
    :go_away,
    :session_resumption_update,
    :voice_activity,
    :usage_metadata
  ]

  @doc """
  Creates a new ServerMessage.
  """
  @spec new(keyword()) :: t()
  def new(opts \\ []) do
    %__MODULE__{
      setup_complete: Keyword.get(opts, :setup_complete),
      server_content: Keyword.get(opts, :server_content),
      tool_call: Keyword.get(opts, :tool_call),
      tool_call_cancellation: Keyword.get(opts, :tool_call_cancellation),
      go_away: Keyword.get(opts, :go_away),
      session_resumption_update: Keyword.get(opts, :session_resumption_update),
      voice_activity: Keyword.get(opts, :voice_activity),
      usage_metadata: Keyword.get(opts, :usage_metadata)
    }
  end

  @doc """
  Converts to API format (camelCase).
  """
  @spec to_api(t() | nil) :: map() | nil
  def to_api(nil), do: nil

  def to_api(%__MODULE__{} = value) do
    %{}
    |> maybe_put("setupComplete", SetupComplete.to_api(value.setup_complete))
    |> maybe_put("serverContent", ServerContent.to_api(value.server_content))
    |> maybe_put("toolCall", ToolCall.to_api(value.tool_call))
    |> maybe_put(
      "toolCallCancellation",
      ToolCallCancellation.to_api(value.tool_call_cancellation)
    )
    |> maybe_put("goAway", GoAway.to_api(value.go_away))
    |> maybe_put(
      "sessionResumptionUpdate",
      SessionResumptionUpdate.to_api(value.session_resumption_update)
    )
    |> maybe_put("voiceActivity", VoiceActivity.to_api(value.voice_activity))
    |> maybe_put("usageMetadata", UsageMetadata.to_api(value.usage_metadata))
  end

  @doc """
  Parses from API response.
  """
  @spec from_api(map() | nil) :: t() | nil
  def from_api(nil), do: nil

  def from_api(data) when is_map(data) do
    %__MODULE__{
      setup_complete:
        (data["setupComplete"] || data["setup_complete"])
        |> SetupComplete.from_api(),
      server_content:
        (data["serverContent"] || data["server_content"])
        |> ServerContent.from_api(),
      tool_call:
        (data["toolCall"] || data["tool_call"])
        |> ToolCall.from_api(),
      tool_call_cancellation:
        (data["toolCallCancellation"] || data["tool_call_cancellation"])
        |> ToolCallCancellation.from_api(),
      go_away:
        (data["goAway"] || data["go_away"])
        |> GoAway.from_api(),
      session_resumption_update:
        (data["sessionResumptionUpdate"] || data["session_resumption_update"])
        |> SessionResumptionUpdate.from_api(),
      voice_activity:
        (data["voiceActivity"] || data["voice_activity"])
        |> VoiceActivity.from_api(),
      usage_metadata:
        (data["usageMetadata"] || data["usage_metadata"])
        |> UsageMetadata.from_api()
    }
  end

  @doc """
  Returns the message type as an atom.
  """
  @spec message_type(t()) :: atom() | nil
  def message_type(%__MODULE__{setup_complete: %SetupComplete{}}), do: :setup_complete
  def message_type(%__MODULE__{server_content: %ServerContent{}}), do: :server_content
  def message_type(%__MODULE__{tool_call: %ToolCall{}}), do: :tool_call

  def message_type(%__MODULE__{tool_call_cancellation: %ToolCallCancellation{}}),
    do: :tool_call_cancellation

  def message_type(%__MODULE__{go_away: %GoAway{}}), do: :go_away

  def message_type(%__MODULE__{session_resumption_update: %SessionResumptionUpdate{}}),
    do: :session_resumption_update

  def message_type(%__MODULE__{voice_activity: %VoiceActivity{}}), do: :voice_activity
  def message_type(_), do: nil

  @doc """
  Checks if this is a setup complete message.
  """
  @spec setup_complete?(t()) :: boolean()
  def setup_complete?(%__MODULE__{setup_complete: %SetupComplete{}}), do: true
  def setup_complete?(_), do: false

  @doc """
  Checks if this is a turn complete message.
  """
  @spec turn_complete?(t()) :: boolean()
  def turn_complete?(%__MODULE__{server_content: %ServerContent{turn_complete: true}}), do: true
  def turn_complete?(_), do: false

  @doc """
  Checks if this is an interrupted message.
  """
  @spec interrupted?(t()) :: boolean()
  def interrupted?(%__MODULE__{server_content: %ServerContent{interrupted: true}}), do: true
  def interrupted?(_), do: false

  @doc """
  Extracts text from server content if present.
  """
  @spec extract_text(t()) :: String.t() | nil
  def extract_text(%__MODULE__{server_content: %ServerContent{} = content}) do
    ServerContent.extract_text(content)
  end

  def extract_text(_), do: nil

  defp maybe_put(map, _key, nil), do: map
  defp maybe_put(map, key, value), do: Map.put(map, key, value)
end
